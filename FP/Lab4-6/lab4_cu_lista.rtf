{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Italic;}
{\colortbl;\red255\green255\blue255;\red191\green100\blue38;\red32\green32\blue32;\red153\green168\blue186;
\red86\green132\blue173;\red254\green187\blue91;\red81\green136\blue67;\red117\green114\blue185;\red88\green118\blue71;
}
{\*\expandedcolortbl;;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c60000\c65882\c72941;
\csgenericrgb\c33725\c51765\c67843;\csgenericrgb\c99608\c73333\c35686;\csgenericrgb\c31765\c53333\c26275;\csgenericrgb\c45882\c44706\c72549;\csgenericrgb\c34510\c46275\c27843;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf2 \cb3 import \cf4 math\
\
a = []\
b = []\
nr = \cf5 0\
\
\cf2 def \cf6 add_list\cf4 ():\
    
\f1\i \cf7 """\
    Functie care adauga un intreg x la finalul listei a si un intreg y la finalul listei b\
    input-lista a si lista b, nr-globale, x,y-input\
    preconditii-l=[l0,l1,...ln-1]; i= 0,n-1; li-intreg, nr-intreg,x-y-nr intregi;\
    output-\
    postconditii-l=[l0,l1,...ln-1]\
\
    """\
    
\f0\i0 \cf2 while True\cf4 :\
        x= \cf8 input\cf4 ()\
        \cf2 try\cf4 :\
            x = \cf8 int\cf4 (x)\
            a.append(x)\
            \cf2 break\
        except \cf8 ValueError \cf4 :\
            \cf8 print\cf4 (\cf9 "Valoarea introdusa nu este un intreg, va rugam reintroduceti"\cf4 )\
\
    \cf2 while True\cf4 :\
        y= \cf8 input\cf4 ()\
        \cf2 try\cf4 :\
            y = \cf8 int\cf4 (y)\
            b.append(y)\
            \cf2 break\
        except \cf8 ValueError \cf4 :\
            \cf8 print\cf4 (\cf9 "Valoarea introdusa nu este un intreg, va rugam reintroduceti"\cf4 )\
    \cf2 global \cf4 nr\
    nr += \cf5 1\
\
\cf2 def \cf6 print_nr_complex\cf4 (x\cf2 ,\cf4 y):\
    
\f1\i \cf7 """\
    Functie care printeaza un numar complex\
    input-x,y\
    preconditii-x->numar intreg y->numar intreg\
    output-print\
    postconditii-\
\
    """\
    
\f0\i0 \cf2 if \cf8 int\cf4 (y) >= \cf5 0\cf4 :\
        \cf8 print\cf4 (x\cf2 , \cf9 "+"\cf2 , \cf4 y\cf2 , \cf9 "i"\cf4 )\
    \cf2 else\cf4 :\
        \cf8 print\cf4 (x\cf2 , \cf4 y\cf2 , \cf9 "i"\cf4 )\
\
\cf2 def \cf6 calcul_modul\cf4 (a\cf2 ,\cf4 b):\
    
\f1\i \cf7 """\
    Functie care calculeaza modulul unui numar complex\
    input-a,b-numere intregi\
    preconditii-a-numar intreg, b-numar intreg\
    output-return modulul unui numar complex\
    postconditii-\
\
    """\
    
\f0\i0 \cf4 a = \cf8 int\cf4 (a)\
    b = \cf8 int\cf4 (b)\
    \cf2 return \cf4 math.sqrt(a*a+b*b)\
\
\cf2 def \cf6 teste_calcul_modul\cf4 ():\
    \cf2 assert \cf4 calcul_modul(\cf5 6\cf2 ,\cf5 8\cf4 ) == \cf5 10\
    \cf2 assert \cf4 calcul_modul(\cf5 6\cf2 ,\cf5 7\cf4 ) == \cf5 9\
    \cf2 assert \cf4 calcul_modul(\cf5 5\cf2 , \cf5 4\cf4 ) == \cf5 6\
    \cf2 assert \cf4 calcul_modul(\cf5 7\cf2 , \cf5 10\cf4 ) == \cf5 12\
    \cf2 assert \cf4 calcul_modul(\cf5 3\cf2 , \cf5 2\cf4 ) == \cf5 3\
\
\cf2 def \cf6 modul10\cf4 ():\
    
\f1\i \cf7 """\
    Functie care verifica daca numarul complex de pe pozitia i are modulul egal cu 10\
    input-lista a si lista b, nr\
    preconditii-l=[l0,l1,...ln-1]; i= 0,n-1; li-intreg, nr-intreg;\
    output-print\
    postconditii-l=[l0,l1,...ln-1]\
\
    """\
    
\f0\i0 \cf2 global \cf4 nr\cf2 ,\cf4 a\cf2 ,\cf4 b\
    \cf2 for \cf4 i \cf2 in \cf8 range\cf4 (nr):\
        \cf2 if \cf4 calcul_modul(a[i]\cf2 ,\cf4 b[i]) == \cf5 10\cf4 :\
            print_nr_complex(a[i]\cf2 ,\cf4 b[i])\
\
\cf2 def \cf6 sterge_element\cf4 ():\
    
\f1\i \cf7 """\
    Functie care sterge un numar de pe o pozitie introdusa de la tastatura\
    input-lista a si lista b, nr, poz\
    preconditii-l=[l0,l1,...ln-1]; i= 0,n-1; li-intreg,poz -intreg;\
    output-\
    postconditii-l=[l0,l1,...ln-1]\
\
    """\
    
\f0\i0 \cf2 global \cf4 nr\
    \cf2 global \cf4 a\cf2 ,\cf4 b\
    \cf2 while True\cf4 :\
        poz= \cf8 input\cf4 (\cf9 "Pozitia:"\cf4 )\
        \cf2 try\cf4 :\
            poz = \cf8 int\cf4 (poz)\
            \cf2 break\
        except \cf8 ValueError \cf4 :\
            \cf8 print\cf4 (\cf9 "Valoarea introdusa nu este un intreg, va rugam reintroduceti"\cf4 )\
    a.pop(poz)\
    b.pop(poz)\
    nr -= \cf5 1\
    \cf2 if \cf4 nr == \cf5 0 \cf4 :\
        a = []\
        b = []\
\
\cf2 def \cf6 suma_nr\cf4 ():\
    
\f1\i \cf7 """\
    Functie care calculeaza suma numerelor complexe de o pozitie de inceput la o pozitie de sfarsit\
    input-lista a si lista b, nr, poz1,poz2\
    preconditii-l=[l0,l1,...ln-1]; i= 0,n-1; li-intreg,poz1-intreg, poz2-intreg;\
    output-s1,s2\
    postconditii-s1,s2-numere intregi\
\
    """\
    
\f0\i0 \cf2 global \cf4 nr\cf2 ,\cf4 a\cf2 ,\cf4 b\
    \cf2 if \cf4 nr == \cf5 1\cf4 :\
        print_nr_complex(a[\cf5 0\cf4 ]\cf2 ,\cf4 b[\cf5 0\cf4 ])\
    \cf2 else\cf4 :\
        \cf2 while True\cf4 :\
            poz1 = \cf8 input\cf4 (\cf9 "Pozitia inceput:"\cf4 )\
            \cf2 try\cf4 :\
                poz1 = \cf8 int\cf4 (poz1)\
                \cf2 break\
            except \cf8 ValueError\cf4 :\
                \cf8 print\cf4 (\cf9 "Valoarea introdusa nu este un intreg, va rugam reintroduceti"\cf4 )\
        \cf2 while True\cf4 :\
            poz2 = \cf8 input\cf4 (\cf9 "Pozitia sfarsit:"\cf4 )\
            \cf2 try\cf4 :\
                poz2 = \cf8 int\cf4 (poz2)\
                \cf2 break\
            except \cf8 ValueError\cf4 :\
                \cf8 print\cf4 (\cf9 "Valoarea introdusa nu este un intreg, va rugam reintroduceti"\cf4 )\
        s1 = \cf5 0\
        \cf4 s2 = \cf5 0\
        \cf2 for \cf4 i \cf2 in \cf8 range \cf4 (poz1\cf2 ,\cf4 poz2+\cf5 1\cf4 ):\
            s1 += \cf8 int\cf4 (a[i])\
            s2 += \cf8 int\cf4 (b[i])\
        print_nr_complex(s1\cf2 ,\cf4 s2)\
\
\cf2 def \cf6 prim\cf4 (x):\
    
\f1\i \cf7 """\
    Functie care verifica daca un numar este prim\
    input-variabila x\
    preconditii-x variabila de tip intreg\
    output-True - daca numarul este prim\
           False - daca numarul nu este prim\
    postconditii-True/False\
\
    """\
    
\f0\i0 \cf4 x = \cf8 int\cf4 (x)\
    \cf2 if \cf4 x < \cf5 2\cf4 :\
        \cf2 return False\
    \cf4 i=\cf5 2\
    \cf4 i = \cf8 int\cf4 (i)\
    \cf2 while \cf4 i*i<=x:\
        \cf2 if \cf4 x%i == \cf5 0\cf4 :\
            \cf2 return False\
        \cf4 i += \cf5 1\
    \cf2 return True\
\
def \cf6 teste_prim\cf4 ():\
    
\f1\i \cf7 """\
    Functie care testeaza functia prim(x)\
    input-\
    preconditii-l=[l0,l1,...ln-1]; i= 0,n-1; li-intreg;\
    output-\
    postconditii-l=[l0,l1,...ln-1]\
\
    """\
    
\f0\i0 \cf2 assert \cf4 prim(\cf5 5\cf4 ) == \cf2 True\
    assert \cf4 prim(\cf5 0\cf4 ) == \cf2 False\
    assert \cf4 prim(\cf5 1\cf4 ) == \cf2 False\
    assert \cf4 prim(\cf5 2\cf4 ) == \cf2 True\
    assert \cf4 prim(\cf5 13\cf4 ) == \cf2 True\
    assert \cf4 prim(\cf5 25\cf4 ) == \cf2 False\
\
def \cf6 eliminare\cf4 ():\
    
\f1\i \cf7 """\
    Functie care elimina numerele care au partea reala numar prim\
    input-lista a si lista b, nr\
    preconditii-l=[l0,l1,...ln-1]; i= 0,n-1; li-intreg;\
    output-\
    postconditii-l=[l0,l1,...ln-1]\
\
    """\
    
\f0\i0 \cf2 global \cf4 nr\cf2 ,\cf4 a\cf2 ,\cf4 b\
    \cf2 for \cf4 i \cf2 in \cf8 range \cf4 (nr-\cf5 1\cf4 ):\
        \cf2 if \cf4 prim(a[i]):\
            a.pop(i)\
            b.pop(i)\
            nr -= \cf5 1\
    \cf2 if \cf4 nr == \cf5 0\cf4 :\
        a = []\
        b = []\
\
\cf2 def \cf6 print_list\cf4 ():\
    
\f1\i \cf7 """\
    Printeaza listele a si b\
    input-lista a si lista b, nr\
    preconditii-l=[l0,l1,...ln-1]; i= 0,n-1; li-intreg;\
    output-\
    postconditii-l=[l0,l1,...ln-1]\
\
    """\
    
\f0\i0 \cf2 global \cf4 nr\cf2 ,\cf4 a\cf2 ,\cf4 b\
    \cf2 if \cf4 nr == \cf5 0 \cf4 :\
        \cf8 print\cf4 (\cf9 "EMPTY LIST"\cf4 )\
    \cf2 else\cf4 :\
        \cf2 for \cf4 i \cf2 in \cf8 range \cf4 (nr):\
            print_nr_complex(a[i]\cf2 ,\cf4 b[i])\
\
\cf2 def \cf6 meniu\cf4 ():\
    v = \cf5 0\
    \cf2 global \cf4 nr\
    \cf2 while \cf8 int\cf4 (v)!=\cf5 7\cf4 :\
        \cf2 while True\cf4 :\
            v = \cf8 input\cf4 (\cf9 "1.Adaugare numar in lista -add \cf2 \\n\cf9 "\
                      "2.Sterge element de pe pozitia data \cf2 \\n\cf9 "\
                      "3.Tipareste numerele care au modulul egal cu 10 \cf2 \\n\cf9 "\
                      "4.Afisati suma numerelor dintr-o secventa data (poz inceput,poz sfarsit) \cf2 \\n\cf9 "\
                      "5.Eliminati din lista numerele cu partea reala numar prim \cf2 \\n\cf9 "\
                      "6.Tiparire lista \cf2 \\n\cf9 "\
                      "7.Iesire din aplicatie \cf2 \\n\cf9 "\cf4 )\
            \cf2 try\cf4 :\
                v = \cf8 int\cf4 (v)\
                \cf2 break\
            except \cf8 ValueError\cf4 :\
                \cf8 print\cf4 (\cf9 "Comanda introdusa nu exista"\cf4 )\
        \cf2 if \cf4 v == \cf5 1\cf4 : add_list()\
        \cf2 elif \cf4 v==\cf5 2\cf4 : sterge_element()\
        \cf2 elif \cf4 v==\cf5 3\cf4 : modul10()\
        \cf2 elif \cf4 v==\cf5 4\cf4 : suma_nr()\
        \cf2 elif \cf4 v==\cf5 5\cf4 : eliminare()\
        \cf2 elif \cf4 v==\cf5 6\cf4 : print_list( )\
        \cf2 elif \cf4 v != \cf5 7\cf4 : \cf8 print\cf4 (\cf9 "Comanda introdusa nu exista"\cf4 )\
    \cf2 if \cf4 v==\cf5 7\cf4 :\
        \cf8 print\cf4 (\cf9 "EXIT"\cf4 )\
teste_prim()\
meniu()\
\
}